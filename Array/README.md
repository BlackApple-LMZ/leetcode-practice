# Array

## 数组是面试题的重点 经常会问到 涉及到各种算法

### 1 返回两个数的和为指定target的下标 * top ！好题
```
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```
思路：寒武纪面试问的这个题；用hash两次遍历或者一次遍历；

### 4 两个排好序的数组 找他们共同的中位数 *** top 好题
```
nums1 = [1, 3] nums2 = [2]  The median is 2.0
nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5
```
思路：二分法，有点难，没有搞明白…

### 11 **
### 15 三个数的和为0的组合 ** top 好题
```
Given array nums = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
思路：O(n^2)的时间复杂度，先排序，然后第一层遍历数组，第二层的话就两个指针左右夹逼，需要加一些判断条件；

### 16 返回最接近target的三个数的和 ** 好题
```
Given array nums = [-1, 2, 1, -4], and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```
思路：就和15题差不多的思路；

### 18 四个数的和为target的组合 **
思路：和15一样；

### 26 排好序的数组移除重复的元素 * 踩的人多
思路：ij指针，如果相等j往后移动，不相等，移动i然后赋值j对应的值；

### 27 数组就地删掉指定的元素 * 踩的人多
```
Given nums = [3,2,2,3], val = 3,
return [2,2]
```
思路：和26差不多，或者将j指针指向最后，如果i需要删除，就把j对应的值传过来，然后j--，交换这个操作和洗牌算法有点像；

### 31 给了一个vector，找出下一个组合数 ** top 好题
```
1,2,3 → 1,3,2 
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```
思路：原地转换，常量的转换时间；原地快排：先找到需要排序的区间，然后对改区间进行排序，自己实现的这种方法，中间有很多判断需要考虑，4ms也还行；solution O(n)的时间复杂度：和我的思路差不多，只不过不需要对改进区间重新排序，因为交换之后是由大到小排序的，只需要将这块区间逆序就行！！！妙啊

### 33 旋转排序数组查找 ** top 好题
```
Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4
Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1
```
思路：就二分查找，只不过需要考虑旋转的情况，在常规二分的基础上，加上一点条件判断，针对begin、mid、end对应的数的大小，判断应该查找的区间；

### 34 排好序的数组 找给定数的起始和终止范围 ** top 好题
```
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
```
思路：就二分查找，循环二分搜索，每次查找到数的时候更新minl和maxr，并继续查找；solution是分两次查找，第一次查找left，第二次查找right，这个想法很妙，比我的思路好；

### 35 一个数的插入位置 排好序的数组 * 好题
思路：二分查找

### 45 跳跃游戏 检查是否可以从第一个跳到最后一个，返回最少跳跃步数 *** top 好题
```
Input: [2,3,1,1,4] Output: 2
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
int jump(vector<int>& nums) {
    if(nums.size()<2)
        return 0;
    int j=1, maxl(nums[0]), step(1), max_pre(nums[0]);
    while(j<nums.size()){
        if(j > maxl){
            maxl = max_pre;
            step++;
        }
        max_pre = max(max_pre, j + nums[j]);
        j++;
    }
    return step;
}
```
思路：就上面的样例代码，j表示index，maxl表示当前能跳的最远距离，max_pre表示maxl范围内下一步跳的最远的距离，就如果超出了maxl，选择max_pre的跳法，因为可以跳的更远；妙啊！！！

### 48 矩阵顺时针旋转90 ** top 好题
```
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
思路：先对矩阵按行反转，然后再将对角线的元素交换，妙啊！！！

### 53 最大连续字数组和 * top 好题
```
Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```
思路：dpi表示以第i个数字为结尾的最大子段和 

### 54 给定一个mxn的矩阵，按照螺旋形状返回一个vector **
思路：用59的套路，做着玩，时间稍微慢点；看了一下solution，自己的写法有点复杂，用方向数组看起来更简单一点，每次出界或者遇到已经访问的元素，就用新的方向，没有回头的操作，**很妙啊**！！！！

### 55 跳跃游戏 检查是否可以从第一个跳到最后一个 ** top 好题
```
Input: [2,3,1,1,4] Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
bool canJump(std::vector<int>& nums) {
    int j=0, maxl(0);
    while(j<nums.size() && j<=maxl){
        maxl = max(maxl, j + nums[j]);
        j++;
    }
    return j==nums.size();
}
```
思路：就上面的样例代码，j表示index，maxl表示当前能跳的最远距离，while的判断条件是j小于index，j能走到之前跳的最远距离；妙啊！！！

### 56 合并重复区间 ** top 好题
```
Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
```
思路：就对区间先排序，然后合并，10分钟AC，然后排序函数如果自己写的话，时间会更快一点，比较简单；

### 57 对于不重叠的区间，给一个新的区间，返回最后合并的区间 *** 大佬的版本可以常熟悉熟悉
```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]
```
思路：56的升级版，其实思路挺简单的，就是有很多坑坑需要踩，提交了好几次弥补完整代码，但是代码写的很乱了……；discuss大佬们给出了很简洁的版本，牛逼，太妙了！！！！！！！！！！！参考sort部分；

### 59 给定n，构建1-n的螺旋矩阵 **
思路：0ms一次过，做着玩？？

### 62 从左上到右下的所有可能结果 ** top 好题
思路：动态规划，也可以用排列组合的思路来做;

### 63 从左上到右下的所有可能结果，中间可能有障碍 **
思路：动态规划，自己写的过程反复进行调整，没有一气呵成，需要二刷一下！！！！！并且最后时间比较慢，solution其实很简单，障碍格对应的通过方法为0；

### 64 最小路径和 ** top 好题
```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```
思路：动态规划，和62差不多;

### 66 计算vector表示的数+1的结果 *
思路：做着玩？？

### 73 mxn的矩阵 将有0的行和列全部置为0 ** 好题
```
Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```
思路：遍历两次，用m+n大小的数组记录含有0的行和列，然后再遍历进行修改；solution空间复杂度为O(1)的解决办法：就是用原矩阵第一行，第一列表示矩阵该行或者该列是否需要全部修改为0，左上角表示行的话，就需要另一个变量来表示列；

### 74 排好序的二维数组查找数 ** 
```
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
```
思路：就两次二分查找，先找在哪一行，再找哪一列；discuss大佬们说直接一次二分查找，因为是完全线性的，妙啊！！！

### 75 相同颜色排在一起 ** top 好题
```
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```
思路：计数排序，先统计频次，再重写nums，two pass很快；follow up要求one pass，有人用三个指针，i遍历，j表示最左，k表示右，i遇到0就和j换，遇到2就和k交换，同时移动指针，妙啊；

### 78 求子集 ** top 好题
```
Input: nums = [1,2,3]
Output:
[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]
```
思路：同17差不多 稍有不同；二刷4ms更快 用时7分钟，代码也更简单；用位操作也可以解决









### 80 排序的数组移除重复次数超过2的数字 **
思路：就用一个指针遍历，另一个指针指向新的更新的位置；挺简单的

### 118 杨辉三角形 *
思路：就做着玩叭… 简单

### 119 杨辉三角形II 返回第n行*
思路：就做着玩叭… 和上面差不多 简单 都是0ms

### 128 乱序数组，求最长连续上升序列的长度 题目要求时间复杂度O(n) ***
思路：没有想出O(n)的方法，先排序，然后遍历，提交过程中遇到一些小BUG，最后成功4ms 99.95%；solution用到了hash set，第一次将vector传递给set去重，然后对set查找i，循环查找i-1 与 i+1 更新长度；但实际来看比排序要慢一点……

### 238 数组除了自己其他元素的乘积 **
思路：第一次遍历把所有数组元素都相乘，第二次除去自己，考虑一些0的情况；
