# BitManipulation
note:
- 感觉位操作可以解决某些hash的题，时间更快！！
- 位操作可以解决穷举类型的题，就是回溯的题，时间并没有快很多；
- 位操作要注意运算顺序，加括号；

### 78 求子集 **
思路：回溯也挺简单的，时间很快，位操作就是穷举所有情况；

### 136 求出现一次的数字 重复数字出现2次*
思路：用hash记录出现一次的数；用位操作，相等异或为0，0和其他数异或为另一个数，太妙了！！！；

### 137 求出现一次的数字 重复数字出现3次**
思路：用hash记录出现一次的数；用位操作，枚举每一位二进制位，统计每一位上这些数为1的数总共有多少个，然后与3相模，如果余1，证明这个出现一次的数的二进制在这位上为1，没有前一个方法快，但是mark！！！；

### 187 重复DNA序列 **
思路：简单的hash法就对10个char构成的string作为key，位操作的话对ACGT进行二进制编码，这样10个char就变成最大值为1048576(2^10)的int hash，然后就可以用位操作替代字符串的substr操作，可以节省很多的时间

### 190 反转二进制数 *
思路：就逆序遍历输入数据的每一位，先右移后左移；discuss大佬用特别妙的反转方法，一半一半的对换，abcdefgh -> efghabcd -> ghefcdab -> hgfedcba；

### 191 求二进制数1的个数 *
思路：常规思路循环移动32次，每次与1进行与操作，为1就是说明该位是1；solution更妙的操作：n与n-1进行与操作 刚好可以改变n的最低1位为0，通过这个计算与的次数就是1的位数，妙啊！！！！；

### 201 求m<<n范围内所有数的与的结果 ** mark 二刷
思路：开始想简单了，认为只需要判断m，n位数是否相等，不等为0，相等为10000这样的，忽略6&7这种情况，没有做出来；discuss大佬们讲这个题其实可以抽象成寻找m，n共同的前缀后面为0 构成的数，妙啊！！！！！！！！；

### 231 判断一个数是否为2的power *
思路：就用191的trick 判断n&(n-1) 如果为0说明就满足题意，对于非正数，直接就返回false，位操作时间复杂度O(1)；

### 260 求出现一次的数字 重复数字出现2次 有两个数字出现一次 discuss太妙了！！！！！**
思路：用hash记录出现一次的数，时间有点慢；discuss用异或的方法太妙了！！！因为要找两个出现一次的数，这两个数肯定不一样，对数组异或就得到了这两个数的异或结果，然后求出这两个数不同的位数，然后根据这个不同的位将原来的数组分成两部分，这样对每部分求异或，就找到这一部分单出来的那个数了，妙啊！！！！

### 268 给了0-n的n-1个数 找到那个缺失的数 * 和136挺像的
思路：就先求和，然后减去给定的vector的数，剩下的就是缺失的；为了避免先求和导致溢出的情况，优化方法是边求和边与num做差；位操作，与index和num同时异或，结果就是缺少的那个数，就相当于认为index也出现一次，就和136思路一样了；

### 338 返回小于num的每个数的1的位数 ** mark一下
思路：dp求解，想出来合适的表达式了，但是实现不是很快；discuss也是dp，但是dp的表达式很简单，很快；

### 342 判断是否为4的power *
思路：和231差不多，需要再加一个判断，num&(0x55555555)，位数必须符合4的位置；

### 371 两个整数的和 位操作妙啊，太妙了！！！！*
思路：其实没啥思路，discuss的方法很妙，用与运算表示进位的情况，因为只有1&1才会是1，就是进位，异或表示求和，0^1这种情况为1，0^0或者1^1都为0，太妙了，循环直到进位是0，也就是没有进位了，就是计算结束了；

### 389 两个string 一个比另一个多了一个char 找出这个char *
思路：第一次用hash；第二次用求和求减，异或也可以，136的string版；

### 401 二进制手表 4位表示小时 6位表示分钟 *
思路：bitset count1出现的次数，如果等于给定的num，就是符合题意的结果；

### 461 求汉明距离 *
思路：就先异或，然后用trick数1的位数；

### 476 求给定数的各位取反的结果 *
思路：将这个数与同位数的全是1的数异或；
