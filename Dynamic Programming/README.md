# Dynamic Programming

*70 爬楼梯 最简单的动态规划 可以将空间复杂度控制在O(1)

*746 最小代价爬楼梯 dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]); 第一次灭有做出来！！！！！状态转移方程写错了

*53 最大连续字数组和 

思路：dpi表示以第i个数字为结尾的最大子段和 

**62 从左上到右下的所有可能结果 

思路：动态规划，也可以用排列组合的思路来做; 

**63 从左上到右下的所有可能结果，中间可能有障碍; 

思路：动态规划;自己写的过程反复进行调整，没有一气呵成，需要二刷一下！！！！！并且最后时间比较慢

**64 最小路径和 

思路：动态规划，和62差不多; 

*303 求指定区间的和 

思路：开始做的时候用二维数组来存结果，导致内存超出，改用一维，通过sum[j+1]-sum[i]的方式计算区间和

**120 三角形从上到下的最短路径和

思路：从下向上推边界条件很简单，从上向下推边界条件就很复杂理！！！！

**931 最小的下降路径和

思路：这个和120思路差不多，从上到下直接推表达式，两次过

**121 买卖股票

思路：可以维护一个递增的栈，这种思路其实可以直接用一个最小值来替代栈，可以节省空间;也可以求各个差值，转化成最大区间和，53题，用dp解决

***123 买卖股票3 可以进行两笔交易

思路：瞬间难了很多，自己的思路是从左整一个最大值，从右扫描也整一个最大值，然后找一个区间断点，使左右两端最大，但是在实现的时候发现最后一步，还是需要O(n2)的时间复杂度……然后就没有做出来，参考大佬们的思路：大佬的思路 发现其实差不多，但是实现起来就很巧妙了，我的想法是从左向右或者从右向左的时候的数组是有增有减的，但大佬是递增的，所以最后就可以直接相加找最大值！！！！很秒啊

***309 买卖股票 有cooldown

思路：瞬间难了很多，自己的思路是从左整一个最大值，从右扫描也整一个最大值，然后找一个区间断点，使左右两端最大，但是在实现的时候发现最后一步，还是需要O(n2)的时间复杂度……然后就没有做出来，参考大佬们的思路：大佬的思路 发现其实差不多，但是实现起来就很巧妙了，我的想法是从左向右或者从右向左的时候的数组是有增有减的，但大佬是递增的，所以最后就可以直接相加找最大值！！！！很秒啊

***174 地牢游戏 hard M×N格子带有加减血，求左上到右下需要的最少血量

思路：课程讲解过的题，从左上到右下比较难，从右下推左上容易推出公式，二刷一次AC

**650 两个键的 游戏 

思路：用dp求解可以，但是时间复杂度还是很高，用因式分解的方法，更快！！！对于寻找素数的方法，首先考虑因式分解。

**873 求一段序列里面最长的斐波那契子序列 

思路：开始想法是对的，用二维dp，i，j代表以ij为结尾的子数列，使用hash也想到了，但是开始不敢实现，后来发现大佬们的想法也差不多，就用于实现，最后写出来了。这个DP[i][j]数组的含义是，以i和j为结尾两个数字的费布拉奇数列长度（i < j）。条件是 A[i] + A[j] = A[k]。

**413 求一段序列里面等差数列的数目 长度必须大于3 连续的 这个题很好了！！！

思路：这道题解出来了，第一次想的简单，用区间dp DP[i][j]数组的含义是，i和j区间是否满足等差数列，发现并没有真的用到递推，其实是伪dp！！！！实际是暴力搜索，但是也能AC，就是时间特别慢。后来发现可以用一维dp，记录res，发现断掉就重新赋值。这样可以AC，时间短了很多，但是思路还是有点不清晰，参考大佬的答案：没有用dp，判断加入的数，满足等差就count加addend，addend是队列长度减2。好牛逼啊，很简洁，但是感觉开始想不出来！！！！！

*198 抢屋子

思路：就常规思路，fi表示第i天抢，fi=max(fi-2 + gi, fi-1)

**213 抢屋子升级版 第一个和最后一个也相邻

思路：分两个情况，抢1到n-1，和2到n，再分别用198 fi=max(fi-2 + gi, fi-1)

**264 丑数2 这个需要关注一下

思路：后面的数肯定是前面的数乘 2 3 5，所以按顺序选n个数，这个题二刷没有想到这个思路，mark一下！！！！！！！！！！！

**279 完全平方数 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

思路：dp[i] = min(dp[i], dp[i-jj]+1); 可以实现，但是时间还是稍慢，不知道是什么情况…

**416 分割等和子集 位操作！！！！

思路：求sum 然后寻找序列的和满足sum/2，dp思路很简单，状态转移方程dp[j] = max(dp[j], dp[j-nums[i]])；因为dp[i]表示0,1 所以状态转移方程用：dp[i] = dp[i] || dp[i - num] 位操作会快很多。这个题也可以用位操作来实现！！！！！！
bits的第i位为1的话表示此数组里面存在组合使得该组合的和为i。
此处采用归纳法简单的分析下算法：
1.假设n之前的子列里面存在1~m,k~L……之间和的组合
2.填加了数字n之后，将会存在(1+n)~(m+n),(k+n)~(L+n)……之间和的组合（只要在上面的组合里面添加当前的元素n即可），在标记bits里面相当于将bits向左边移动n位，即bits << n
3.故目前为止，存在1~m,k~L……以及(1+n)~(m+n),(k+n)~(L+n)……之间和的组合
4.故bits |= bits << n
妙啊！！！！！

# 背包问题：http://www.cnblogs.com/jbelial/articles/2116074.html
1 01背包：
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大；

思路：f[i][v]表示剩下v的空间，放前i个物品得到的最大价值；这个必须得整明白，开始先用二维dp来做，然后用一维dp进行优化，优化太妙了！！！要注意前后的顺序，先对i循环，内层对v进行循环。f[i][v]和f[i-1][v]有关系，所以i应该放在循环的外层。f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}

2 完全背包：
有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

思路：将完全背包问题转化为01背包问题的思路：将一种物品拆成k=V/c[i]件物品，然后在二层循环以内，再对k进行循环，查找那个k最优秀；但这个太慢了…所以有优化。之前经常将01背包问题写成完全背包问题…f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}注意与前面的区别啊啊啊啊啊啊啊

3 多重背包：
有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

思路：f[i][v]=max{f[i-1][v-k*c[i]]+ k*w[i]|0<=k<=n[i]} 把多重背包问题转换成01背包，就是n[i]个相同的物品，复杂度是O[Vn求和]，如果将物品按照2^n进行拆分，就又可以进一步优化 具体看代码 很妙了

4 混合背包：
就是上面三种背包结合到一起，01背包与完全背包就通过if判断来选择是从前到后循环，还是从后到前循环，多重背包就转成01背包来解决。
for i=1..N
if 第i件物品是01背包
for v=V..0
f[v]=max{f[v],f[v-c[i]]+w[i]};
else if 第i件物品是完全背包
for v=0..V
f[v]=max{f[v],f[v-c[i]]+w[i]}; 

5 二维费用的背包问题 妙啊！！！！！！
二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。

思路：费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}。物品总个数的限制：有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。

6 P06: 分组的背包问题
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

思路：这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}。

使用一维数组的伪代码如下：
for 所有的组k
for 所有的i属于组k
for v=V..0
f[v]=max{f[v],f[v-c[i]]+w[i]}

另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。

**322 硬币找零 完全背包问题

思路：就用前面的分析，一次过，但是时间稍慢，用林沐大佬的，效果也差不多；都用的dp，有的人就很快了，实现也是有优化的地方

**518 硬币找零2 完全背包求方案总数

思路：一把AC，和322差不多，将取最小值换成求和，边界条件修改一下。硬币找零的变形问题，在上面的博客里面有很详细的分析讨论！！！！！！看了一下优化代码，将对amount的循环从coins[i]开始，自动排除if里的条件，省去了很多的比较，所以快了很多！！！！！！！这一点要get

#区间dp

**486 预测胜者：一组线性数据，只能选取头尾，最后分数高者胜 题不错，以后复习复习

思路：就经典的区间dp，虽然一次做出来了，但是想了好久…
