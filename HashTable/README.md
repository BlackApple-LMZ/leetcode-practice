# HashTable
note: 
- 对于O(n^2)的暴搜算法，考虑用滑窗来优化时间；
- 能用unordered_map就不要用map 因为哈希表查找比红黑树快很多；
```
int lengthOfLongestSubstring(string s) {
    int used[128] = {-1};
    int start(-1);
    int length(0);
    for(int i=0; i<s.size(); i++){
        if(used[s[i]]>start){
            start = used[s[i]];
        }
        length = max(length, i-start);
        used[s[i]] = i;
    }
    return length;
}
```
### 1 两个数的和 *
思路：就用哈希表，思路很清晰，开始用的map，速度慢，用unordered_map之后 快了很多

### 3 不重复字符的最长子串 必须再刷！！！**
思路：第一次暴搜过，但是很慢很慢；solution用滑窗法，但是自己写还是没有写对，必须mark！！！！！！

### 16 3个数的和为0 ** 和18差不多
思路：先排序，然后遍历i，剩下左右夹逼，时间还算快；

### 18 一个数组，返回满足四个数的和为target的所有情况 ** 两指针法
### 30 见滑窗法 ***
### 36 验证数独的有效性 **
思路：用unordered_map<char, vector<int>>，对每行，每列，以及每块分别设置哈希函数，遍历一次输入数组与hashmap求最后结果；discuss直接用三个数组更简单啊……

### 37 解数独 ***
思路：在36基础上用回溯的思想求解，为了简单，开始把待求的i，j压入到queue里面，然后每次取头部进行递归，第一次卡在了引用上面，然后第二次过了，时间很慢很慢……60ms；**discuss 取消queue 直接传递i，j 快了很多 4ms 能不用stl就不用；**

### 49 Anagrams进行分组 **
思路：对string排序后的结果作为key，vector作为val，时间复杂度O（NKlogK）；思路2是26长度的vector向量表示str，作为key；

### 76 见滑窗法 ***
### 136 找数组中单独出现的数，当时面试问到的题目！！！！！ *
思路：用哈希表可以实现On 但是用为操作 异或可以更快 相同的数异或为0，0和其他数异或为1;

### 137 给定数组，某个元素出现1次，其余出现3次，找到出现1次的数 136升级版**
思路：就用了hashmap，位操作也必须掌握哦！！！

### 187 重复的DNA序列 返回长度为10，出现超过一次的子序列**
思路：就用hashmap存下来，超过一次输出；位操作更快；

### 202 高兴数 * Explanation: 后面的2表示平方 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1
思路：用哈希表存下出现过的数，一旦重复就false;方法二是快慢指针，一旦快追上慢，就false;平方和最后肯定会小于10，只有1和7才会true！！！妙啊

### 204 找n以内的质数数量 * 这个mark一下！！！
思路：用hash表示不符合的数，用数组能提升一倍的时间；

### 205 对称字符串 *
思路：就用hashmap互相存字符串，改用char数组会快很多；

### 217 判断有无重复字符串*
### 219 见滑窗法*
### 220 见滑窗法** fail
### 242 *
### 274 **
### 290 单词模式 pattern = "abba", str = "dog cat cat dog" true *
思路：就用map，需要考虑pattern与str提取word的数量是否一致，考虑是否一一对应，并且char没有被重复使用；discuss有大佬用istringstream处理带空格的输入流，这种写法很妙，必须mark！！！！然后就是和上述描述一样的判断；

### 299 bull和cow的游戏 猜数字，大小对位置对就是bull，大小其余地方有，但是位置不对是cow，返回bull和cow的数量；两个vector替代map的方法mark！**
思路：第一次记录没对上的数字，第二次进行查找，第一次提交错误，忽略了"1122" "1222" 这种情况；discuss1用和我一样的two pass，但是用**两个vector替代map**，可以节约查找的时间妙啊！！！！discuss2用两个map，其实也可以用vector，但是用的one pass的方法，也很妙

### 349 求两个数组相同的数 不包含重复的数 *
### 350 求两个数组相同的数 包含重复的数 *
思路：就两个unordered_map解决问题；

### 387 string中第一个单独的char对应的index *
思路：第一次遍历记录table，第二次查找值为1的情况；

### 389 和136一样，只不过两个string，一个多了一个char *
思路：第一次遍历记录s，第二次遍历t，查找多出来的char；

### 409 由给定的char构建最长的回文string的长度*
思路：hashmap统计char，偶数加，奇数只加一个；

### 438 见滑窗法* 
### 451 按照char出现频次重新排序 mark 思路挺好的！！！！**
思路：记录char出现频次，然后sort，然后输出；自己比较用了pair，其实重写sort比较函数很简单；然后discuss大佬们**对统计的频次table进行桶排序**，O(n)复杂度，妙啊！！！；

### 454 4个数的和II **
### 463 岛屿(1连接成的区域)周长 *
思路：对于每个1，根据周围0或者边界的数量，决定周长是否++ 一次通过；也可以用4x方格数-2X相邻边数目来计算；

### 500 判断字符是否为键盘同一行 *
思路：hash表缓存每个大小写字母对应的行数，注意ASCII码大小写中间还有6个字符……；

### 508 **
### 525 01序列，求0,1个数相等的最长序列长度 solution的方法必须mark！！！！太妙了**
思路：O(n^2)暴搜没有过……；solution对累加和记录hash，如果出现前后两次累加和相同，表明中间的部分和为0，就是满足题意的区间，就用hashmap维护出现累加和与对应最小index的pair，用vector查找快，时间更快，hashmap内存小；

### 535 编码**
### 554 砖墙最小的打破数 **
思路：对每行的数累加求和，用hashmap统计频次，出现次数最多的累加和就是最终的结果，自己是两次遍历，第二次遍历hashmap；discuss直接在第一次的时候就不断更新最大值；

### 560 求数组连续子数组和为k的个数 ** 必须二刷solution；
思路：就O(n^2)的思路，用sum数组缓存一下；solution更牛逼的思路：有点类似525的思路，如果累加和与之前的和相差k，就加上之前的数据；

### 594 最大和谐序列 和谐序列是指序列最大值与最小值相差1以内 *
思路：先排序，然后对排序后的数组检测相邻差为1的数据的数量 一次过；**solution需要再看一下**

### 599 两个数组最小公共数的index *
思路：hashmap，记录第一个数组的下标，遍历第二个数组，在第一个里面出现，就维护最小值，注意更新最小值的时候更新res，等于最小值的时候res添加；

### 645 *
### 690 员工的重要性 *
思路：给了一个特殊的数据结构Employee，表示员工的关系网络，然后求指定id以及和他有关系的所有id的sum和；就用队列加宽搜，hashmap表示id与Employee的对应关系，还有id与是否添加的对应关系；挺简单的，一次过；solution没有考虑id与是否添加的对应关系；

### 720 字典中最长的单词 *
思路：先排序，然后按顺序查找添加hashmap；solution有用字典树的方法，这个先放了，没有看……
