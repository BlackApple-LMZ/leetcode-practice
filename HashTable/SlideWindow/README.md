# SlideWindow

note:滑窗在字符串和数组方面很常用，结合hashmap，一般处理**连续**的字符串，有变长和定长的滑窗。
```
void slidingwindows(vector<int> nums,int k)
{ 
    先预处理 
    然后进行滑动窗的循环，一般是个while循环，同时实现定义好滑动窗的起点和终点，同时还有一个是记录当前状态的数或者数组，比如count 
    int begin = 0, end = 0; 
    int count = 0; 
    while(end<nums.size()){ 
        1.在循环里先是当前end到达的时候，更新count 
        2.判断更新完后是否满足条件，比如count<k 
        3.如果满足的话，可以进行一些处理，如果是求最小长度之类的，会在满足时进行操作 
        4.如果不满足的话，也需要进行一些处理，比如求最大长度之类的，会在此时进行操作 
        以上3,4条常见的操作就是一个while循环，进行左边界begin的收缩处理，一直到收缩到满足/不满足条件为止 
    } 
}
```
### 209 无序数组，求最小满足给定和的长度 ** 再刷！！！
思路：第一次没有做出来，过一段时间看也没有简单想法，看了滑窗之后再刷两次过，第一次没有考虑特殊情况。经典滑窗法，或者说两个指针法：先更新右端，然后满足给定条件之后，缩短左边界，求最小值；

### 219 求数组连续k范围内是否存在相等的数 *
思路：hashmap维护滑窗内的次数，超出窗的部分--，新进来的++，如果新来的数据已经在hashmap里面了，说明有重复，满足要求；

### 220 求数组连续k范围内是否存在差小于t的数 ** fail 二刷
思路：和219思路差不多，有点贪心的地方是|x - nums[i]| <= t  ==> -t <= x - nums[i] <= t ==> x-nums[i] >= -t ==> x >= nums[i]-t 只需要找到满足nums[i]-t的最小值，然后再判断x - nums[i] <= t是否成立；妙啊！！！
