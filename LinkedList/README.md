# LinkedList
notes for LinkedList

1 链表节点必须要初始化！！！

2 如果是原地调整链表的顺序或者新创建了链表 最后的节点一定要指向NULL 否则会有环……

3 链表的头节点问题 设置节点p，p作为头节点（没有实际意义），结束后返回p->next即可

*2. 链表表示的两个数求和 

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) 
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807

思路比较简单，就是模拟加法的过程 考虑进位的情况

**19. 移除链表倒数第n个节点 

Given linked list: 1->2->3->4->5, and n = 2  Output 1->2->3->5.

思路: 先求出length，然后移除第length-n+1个node;用快慢指针，开始快指针先前移n个位置，然后和慢指针一同移动;


*21. 合并两个链表 

思路: 设置链表头移动;


***23. 多个链表进行合并

Input:[ 1->4->5, 1->3->4, 2->6 ]  Output: 1->1->2->3->4->4->5->6

思路: 分治的思想，两两比较然后合并;

***24. 链表相邻元素进行交换

Given 1->2->3->4, you should return the list as 2->1->4->3.

思路: 就三个指针 来回交换 二刷的时候 败在了while的循环条件，对pre进行判断；

***25. 按照k组反转链表

Given this linked list: 1->2->3->4->5  For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5

思路: 先求出整个链表的长度，然后循环链表，对k长度的部分进行链表反转，然后再和之前的连接起来，这个第一次做出来了，费了一定的时间；

**206. 整个链表进行反转 ！！！！！！！！！！面试经常问到

Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL

思路: 就常规反转，必须得烂熟于心；

**92. 部分链表进行反转

Input: 1->2->3->4->5->NULL, m = 2, n = 4  Output: 1->4->3->2->5->NULL

思路: 需要考虑tail以及pre的情况，这个二刷还是三刷的时候问题不大；

**61. 链表右移

Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL

思路: 先求出length，然后将链表的尾巴连接到头结点上，从head开始走n-k%n步的位置那里断开成一个新的链表，没有二刷，但感觉问题不大；

*83. 删除排好序链表的重复节点，只保留一个

Input: 1->1->2->3->3 Output: 1->2->3

思路: 很简单，和下一个val一样，就把next指向next的next；


**82. 83的升级版，删除排好序链表的重复节点，重复的不保留

Input: 1->2->3->3->4->4->5 Output: 1->2->5

思路: 稍微有点难度，二刷改了两次，ac，整一个pre进行操作；

**86. 链表划分 小的部分在大的部分前面

Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5

思路: 就整两个头，然后分别指向小的部分和大的部分，最后拼接；

**328. 链表奇偶重新排序

Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL

思路: 同上，就整两个头，然后分别指向奇和偶，最后拼接；

**138. 带有随机指针的copy

思路: 用map将之前的链表的指针和顺序对应记录，然后就知道了随机指针的顺序，然后再对新链表进行操作；

***141. 判断链表有没有环

思路: 快慢指针，如果快指针追上慢指针，就是有环；

***142. 判断链表有没有环，并且找出环的位置

思路: 快慢指针，如果快指针追上慢指针，就是有环，然后基于数学原理，从meet和head分别向下走，相遇的点就是环的交点；

**143. 对链表重新排序

Given 1->2->3->4, reorder it to 1->4->2->3.

思路: 用快慢指针找到中间节点，断开，把后半截单链表 reverse 一下，再合并两个单链表。

**160. 求两个链表的交点

思路: 1.用哈希表存下一个链表的地址，然后查找第二个链表的地址。2用两个指针向前走，然后互相交换，判断是否相等；这个可以省去求长度的过程

*203. 删掉链表指定元素的节点 思路: 就元素一样，就跳过

*237. 删掉链表指定节点 思路: 就查到节点，然后跳过

*234. 判断链表是否为回文链表

Input: 1->2->2->1 Output: true

思路: 快慢指针找到中间节点，然后对后面反转，然后比较这两个list

*876. 返回链表中间后面部分 思路: 快慢指针找到中间节点，然后返回
