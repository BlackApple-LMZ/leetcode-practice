# Tree

总结：栈的递归操作就符合前中后三种遍历顺序;迭代操作一般就和stack结合！！！！ 剩下：863、834、684、685

树一般就用分治的思想，然后用递归来实现，分治的过程中要考虑相应的操作是在前中后哪个位置进行！！！

二叉搜索树的中序遍历是一个递增序列！！！！这一点很重要，二叉搜索树可以用中序遍历解决问题！！！783=530

宽搜demo 515 

迭代方法例题：94，606，617 中序遍历的迭代法 230

**94 中序构建树 迭代重点，线索二叉树也要掌握！

思路：递归很简单，迭代的方法也要掌握！！！！用栈维护数据如果到树的叶子节点，就弹出操作；用线索二叉树！！！！这个方法很巧妙，将二叉树拉直成一条链，然后直接输出；

*100 判断是否为相同的树 很简单了 就递归或迭代

*101 判断树是否为对称的 和100差不多 左右对比不是左左

**102 求二叉树的每层的数据 深搜宽搜都可以 很简单了

### 103 求二叉树的每层的数据 隔一层正反换一下 **
思路：宽搜也很简单了 多一个反转的操作；如果不用反转的话，就用vector；

*104 树的最大深度… 

**105 给定树的前序遍历和中序遍历 恢复树 值传递和引用传递导致的时间空间开销必须mark！！！！！！！！！！！！！！

思路：就用分治的办法，每次传入两个区间，对该区间进行递归构建树，one pass但是时间效率太低…同样的思路，别人的效率就很高！！！！！难受 啊啊啊啊，原来是我的迭代函数采用了值传递！！！！！！导致时间空间效率低了很多！！！！！！改成引用之后就前95%了

**106 给定树的后序遍历和中序遍历 恢复树 思路和105一样 后面889给前序和后序

*107 103从底向上输出 103反转，深搜后序压入数据更好

*108 给定升序序列 构建平衡BST 就类似分治的递归one pass

*110 判断一棵树是否为平衡二叉树 就后序遍历，返回深度，然后一个变量控制是否平衡；比较简单

*111 树的最小深度 这个有点意思 也挺简单的

*112 路径和 判断是否存在从根节点到叶子节点和为给定sum 113 437

**113 对112 返回所有的满足路径

**114 将二叉树转成链表树 感觉和哪个提到思路很像来着 这个关注一下 想法还是很好的

思路：左树不为空，就把右子树续在左子树最右下面，然后左子树变成root的右子树，左子树为null；左子树为空，就走右边；one pass

**116 给定一棵完全树 对这个树添加向右的指针；这个mark一下

思路：就从上到下

**117

**129

### 144 树的中序遍历 **
思路：递归，迭代用栈，很妙；

### 145 树的后序遍历 ***
思路：递归，迭代用栈，这个有点小难；

### 173 BST迭代器设计 **
思路：平衡搜索树，中序遍历就正好是单调递增序列，维护一个栈 one pass；

**199 二叉树从右边看的序列 这个就宽搜，更新末尾值或者深搜，纵向更新，没啥好说的

**222

*226 翻转二叉树

思路：递归就很简单，迭代的话不能用深搜，得用宽搜来进行迭代操作，这个可以小小的关注一下！！；

**230 BST第k个小的元素

思路：就中序遍历一次过；

*235

**236

*257 获得二叉树的path string表示 就深搜 很简单了

**337 在树上抢财产 没有做出来！！！！mark二刷

思路：很妙的递归！！！返回当前节点的最大值，然后参数传递上一轮的最大值，然后最新的最大值是root和上一轮的值与root->left root->right和中的最大；或者不整这样，直接返回一个pair 上一轮最大和上上轮最大；

*404 计算左叶子节点的和 挺简单的

*429 输出多叉树每一层的节点 就深搜或者宽搜 深搜的话纵向补充数组，宽搜横向补充

*437 计算路径和3 求出给定路径和的路径数 做了有一会儿

思路：遍历树，对每个节点计算一下起始路径；

**450 BST删除node 还是有点小复杂

思路：搜索BST 查找到节点之后，判断右树空不空，不空，就把左子树续到右子树的最左节点下面，空就把左树续过来；自己的思路没什么问题就是实现不是很精简，solution有很不错的题解，用递归的办法；

*501 BST出现频率最高的val 开始以为挺难的，一直没做，后来发现和508思路一样……

思路：不用hashmap O1空间复杂度就是遍历两次树，第一次找到最大频率，第二次遍历的时候压入最大频率的数；

**508 获取树sum频次最多的sum one pass

思路：遍历树，用hashmap存储sum与其对应的频次，然后再push频次最高的val，自己做的时候最大频次单独计算，可以在遍历树的时候，就更新最大频次；

**513 找到树最底行最左边的元素 也是宽搜 深搜可能更简单

**515 找树每一行的最大值 这个就不说啥了……

*530 同下面783

*538 将BST转成较大树 第一次做了有段时间，做出来了，但还需要再刷一下！题不错 思路：中序遍历，先右后左的中序遍历

*543 二叉树的直径 过root的最长距离 感觉和哪个题挺像的…

*559 多叉树的最大深度 深搜，宽搜…

*563 计算所有节点的tilt 第一次没有做出来……没有理解题意 

思路：后序遍历，计算abs，按照题目的意思，要加上当前node的value

*572 判断一棵树是否为另一颗树的子树 表示成字符串的思想和特殊操作mark一下！！！

思路：将两颗树分别表示为字符串，两个操作：一是在数字前加特殊字符避免23 3这样的情况;二是对左右空节点分别用lnull和rnull表示;第二个方法就是逐个节点比较，开始用这个想法搞出来的;

*589 多叉树的前序遍历

思路：递归很简单，迭代用栈维护也很简单；

*590 多叉树的后序遍历 迭代法需要再刷一次啊！！！！
 
思路：递归很简单，迭代用栈，但是没有想出来……discuss里面有人用前序遍历的迭代法，从vector的前面数据，倒也是个办法……用双栈法，这个需要mark一下！！！速度比其他方法都要快；

*606 用括号加数字表示树 这道题必须再刷几次！两种方法

思路：用前序遍历搜索树，但是写的时候遇到情况多，有点混乱…solution很简洁了;用迭代的操作，结合栈，这个也要尝试写一下！！！！

*617 两颗二叉树合并 有时间再刷

思路：递归solution实现很简单，需要学习！迭代的方法很妙！！

**623 给树增加一行 

思路：就递归深搜，常规操作，和solution内容相差无几；

*637 求树每一层的平均值

思路：用广搜，求平均值，常规操作，我用queue存node和depth的pair，solution是用两个queue，新加的内容放在第二个queue；下一次可以尝试一下深搜，用vector记录每层访问的数据，遍历树结束之后，求每层的平均值

**652 找树重复的子树 第一次没有做出来！！需要再刷一下啊

思路：开始想法是将树的所有path存下来，然后两两从末尾比较，遇到不同的节点就找到最近的相同node，有个问题就是这个node可能重复，和题目要求不一样……；solution的思路1是将每个节点到结尾表示的string存到hash map里面，如果次数大于2认为存在重复，就返回其root，很妙啊！！！时间复杂度On2，因为表示成字符串，和树的N有关；思路2 用位操作？？？

*653 在BST上寻找两个数的和 这个题虽然简单，一次过，但是方法有很多，hashmap的方法值得二刷！！！

思路：我的想法是对树的每个节点再在二叉搜索树上进行搜寻；solution1是在遍历树的过程中将val存起来，然后对当前节点查找K-val，只需要遍历一次；2用宽搜加hashmap的方法，可以稍微更快一点；3先中序遍历获取二叉搜索树对应的递增序列，然后用l和r指针，判断是否存在和为target的情况！！！这个也很巧妙；

**654 用给定的vector构建一颗要求的树  这个题很清新，discuss有On的解决方法！！！！必须二刷

思路：和solution的思路一样，就是找到最大值，然后对左右两边分别操作，但是实现速度特别慢On2的时间复杂度……On结合栈的方法简直太妙了！！！

**655 打印树

思路：先求出树的高度，然后传入lr参数，每一行求中间的mid修改内容，然后递归左右子树；

**662 找到树的最大宽度，最左和最右中间的null也算宽度

思路：开始给每个节点捆绑一个index，然后给的例子里面index超出了int最大值，没能通过全部的demo，开始也理解错题意了，认为要求最大的index，然后就放弃了；solution也是用index的思想，深搜，维护最左边的index，换成宽搜就不需要这样了，就是左：2*index右：2*index+1 用unsigned int替代int就可以过那个超出int范围的实例了；

*669 根据给定的范围修剪二叉搜索树 复习的时候可以看看，毕竟开始的时候没有一下想出来…… 其实很简单了

思路：开始没什么想法，后来用分治的思想，就one pass；和solution思想一样

*671 在特殊树上寻找第二小的值 第一次做出来了，但是值得二刷！

思路：就深搜，然后维护一个第二小的值，如果值相等就继续往下搜，不相等就进行判断比较，递归和迭代的时间复杂度应该没差多少；

*687 寻找树中最长相等序列的长度 必须值得二刷！！！就是很经典啊

思路：开始以为挺简单的，然后第一次没有做出来…solution的想法很妙了，后序遍历，然后维护长度以及左右支树的最大长度；

*700 二叉树查找 特别简单了

思路：就直接从上向下搜索，O(H)的复杂度；

**701 给二叉搜索树增加节点

思路：自己的想法，就从上到下遍历树，如果走到二叉树的叶子节点，就把数插入在这个位置；发现discuss大家也都是这样的思路，就有人的代码比我简洁，mark一下

*783 求二叉搜索树值的最小差 同530 中序遍历再刷一次！！！

思路：第一次做对每个节点遍历，然后再在二叉搜索树中找与其最接近的距离，维护一个最小距离，两次过但是不是最优算法；discuss中有大佬提示用中序遍历，因为二叉搜索树的中序遍历是递增的，所以直接两两比较，就可以找到最小间距！！！！很妙，二刷一下。

*814 对一棵只有0，1的树，修剪不含1的子树

思路：就深搜然，第一第二次刷都ok，一刷：左右节点都为空，根据值为1返回root还是NULL；二刷：计算左右返回值，和solution一样，和一差不多，简单；

**865 找出所有深度最深节点的最小子树，在答案的思路下，解出来了，方法二值得二刷！！！！！

思路：第一步先遍历整个树，并对深度进行标记，就是用一个map，然后再遍历一次树找最深的节点或者公共节点，其实思路很简单，就是用map标记这个开始没有这样想；第二种方法一次遍历，同时返回深度与节点，很妙！！！；

*872 判断两棵树的叶子节点序列是否相同，递归一次做出来，迭代需要再刷一下，方法很棒！！！

思路：用递归的方法，分别获得两棵树的叶子序列，然后比较；用迭代的方法，实时比较叶子序列，这个很巧妙了！！！！

**889 给定树的后序遍历和前序遍历 恢复树 
