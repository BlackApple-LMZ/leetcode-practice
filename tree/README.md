# Tree

总结：栈的递归操作就符合前中后三种遍历顺序;迭代操作一般就和stack结合！！！！

迭代方法例题：94，606，617

**94 中序构建树 迭代重点，线索二叉树也要掌握！

思路：递归很简单，迭代的方法也要掌握！！！！用栈维护数据如果到树的叶子节点，就弹出操作；用线索二叉树！！！！这个方法很巧妙，将二叉树拉直成一条链，然后直接输出；

*563 计算所有节点的tilt 第一次没有做出来……没有理解题意 

思路：后序遍历，计算abs，按照题目的意思，要加上当前node的value

*572 判断一棵树是否为另一颗树的子树 表示成字符串的思想和特殊操作mark一下！！！

思路：将两颗树分别表示为字符串，两个操作：一是在数字前加特殊字符避免23 3这样的情况;二是对左右空节点分别用lnull和rnull表示;第二个方法就是逐个节点比较，开始用这个想法搞出来的;

*606 用括号加数字表示树 这道题必须再刷几次！两种方法

思路：用前序遍历搜索树，但是写的时候遇到情况多，有点混乱…solution很简洁了;用迭代的操作，结合栈，这个也要尝试写一下！！！！

*617 两颗二叉树合并 有时间再刷

思路：递归solution实现很简单，需要学习！迭代的方法很妙！！

**623 给树增加一行 

思路：就递归深搜，常规操作，和solution内容相差无几；

*637 求树每一层的平均值

思路：用广搜，求平均值，常规操作，我用queue存node和depth的pair，solution是用两个queue，新加的内容放在第二个queue；下一次可以尝试一下深搜，用vector记录每层访问的数据，遍历树结束之后，求每层的平均值

**652 找树重复的子树 第一次没有做出来！！需要再刷一下啊

思路：开始想法是将树的所有path存下来，然后两两从末尾比较，遇到不同的节点就找到最近的相同node，有个问题就是这个node可能重复，和题目要求不一样……；solution的思路1是将每个节点到结尾表示的string存到hash map里面，如果次数大于2认为存在重复，就返回其root，很妙啊！！！时间复杂度On2，因为表示成字符串，和树的N有关；思路2 用位操作？？？

*653 在BST上寻找两个数的和
